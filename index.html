<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <title>Tetris</title>
    <style>
        body {

            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: black;
        }

        .canvas-container {
            position: relative;
            margin: 0px;
            padding: 0px;
        }

        canvas {
            background-color: black;
            background-image: url("scanlines2.png");
            background-repeat: unset;

            z-index: 1;
        }

        .canvas-container::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background-image: url("https://s3-us-west-2.amazonaws.com/s.cdpn.io/86186/crt.png");
            background-repeat: no-repeat;
            background-size: 100% 100%;
            /* Adjust the transparency as needed */
            z-index: 22;
            pointer-events: none;
            /* Ensures it doesn't interfere with canvas interactions */
        }
    </style>

</head>

<body>

    <div class="canvas-container">
        <canvas id="myCanvas" width="900" height="1600"></canvas>
    </div>

    <script>

        document.addEventListener("DOMContentLoaded", function () {


            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");


            let gameInterval;

            let score = 0;
            let lines = 0;
            let level = 1;
            const wTile = 10;
            const hTile = 20;

            resizeCanvas();

            window.addEventListener("resize", resizeCanvas);

            function resizeCanvas() {
                const aspectRatio = 9 / 16;
                const maxWidth = window.innerWidth;
                const maxHeight = window.innerHeight;

                let canvasWidth = maxWidth;
                let canvasHeight = maxHeight;

                // Calculate canvas dimensions while maintaining aspect ratio
                if (canvasWidth / canvasHeight > aspectRatio) {
                    canvasWidth = canvasHeight * aspectRatio;
                } else {
                    canvasHeight = canvasWidth / aspectRatio;
                }

                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
            }

            let ch = canvas.height;
            let cw = canvas.width;

            const subbar = ch * 0.20;
            let startingPositions = [30, 30]
            const bs = (ch - startingPositions[0] * 2 - subbar) / hTile; // size

            let speed;

            let lastLineCleared = 0;
            let combo = 0;


            // tetrominos
            let currentTetro;
            let nextTetro;
            let heldTetro;
            let gameArray = Array.from({ length: hTile }, () => Array(wTile).fill(null));
            let bag = [];

            let dash = 0;
            let dashPos = [];



            let musicOn = true;

            const buttonImage = new Image();
            const buttonPressedImage = new Image();
            buttonImage.src = 'button.png';
            buttonPressedImage.src = 'button2.png';

            const logo = new Image();
            logo.src = 'tetrislogo.png';

            var crtLines = new Image();
            crtLines.src = "scanlines.png";

            // Make sure you've included the glfx.js script in your code!

            // Here I load a PNG with scanlines that I overwrite onto the 2D game's canvas.
            // This file happens to be customized for the demo game, so to make this a
            // general solution we'll need a generic scanline image or we'll generate them
            // procedurally.
            // Start loading the image right away, not after the onload event.

            window.addEventListener('load', drawStartButton, false);

            function fakeCRT() {
                var glcanvas, source, srcctx, texture, w, h, hw, hh, w75;

                // Try to create a WebGL canvas (will fail if WebGL isn't supported)
                try {
                    glcanvas = fx.canvas();
                } catch (e) { return; }

                // Assumes the first canvas tag in the document is the 2D game, but
                // obviously we could supply a specific canvas element here.
                source = document.getElementById("myCanvas");
                srcctx = source.getContext("2d");

                // This tells glfx what to use as a source image
                texture = glcanvas.texture(source);

                // Just setting up some details to tweak the bulgePinch effect
                w = source.width;
                h = source.height;
                hw = w / 2;
                hh = h / 2;
                w75 = h * 1;

                // Hide the source 2D canvas and put the WebGL Canvas in its place
                source.parentNode.insertBefore(glcanvas, source);
                source.style.display = 'none';
                glcanvas.className = source.className;
                glcanvas.id = source.id;
                source.id = 'old_' + source.id;

                // It is pretty silly to setup a separate animation timer loop here, but
                // this lets us avoid monkeying with the source game's code.
                // It would make way more sense to do the following directly in the source
                // game's draw function in terms of performance.
                setInterval(function () {
                    // Give the source scanlines
                    srcctx.drawImage(crtLines, 0, 0, w, h);

                    // Load the latest source frame
                    texture.loadContentsOf(source);

                    // Apply WebGL magic
                    glcanvas.draw(texture)
                        .bulgePinch(hw, hh, w75, 0.05)
                        .vignette(0.25, 0.44)
                        .noise(0.02)
                        .vibrance(0.1)
                        .update();
                }, Math.floor(1000 / 40));
            }

            // with default positions
            const tetrominos = [
                { name: "i", tl: [0, 0], positions: [[0, 1], [1, 1], [2, 1], [3, 1]], color: "cyan", orientation: 0 },
                { name: "l", tl: [0, 0], positions: [[2, 0], [0, 1], [1, 1], [2, 1]], color: "orange", orientation: 0 },
                { name: "j", tl: [0, 0], positions: [[0, 0], [0, 1], [1, 1], [2, 1]], color: "blue", orientation: 0 },
                { name: "o", tl: [0, 0], positions: [[1, 0], [2, 0], [1, 1], [2, 1]], color: "yellow", orientation: 0 },
                { name: "z", tl: [0, 0], positions: [[0, 0], [1, 0], [1, 1], [2, 1]], color: "red", orientation: 0 },
                { name: "t", tl: [0, 0], positions: [[1, 0], [0, 1], [1, 1], [2, 1]], color: "purple", orientation: 0 },
                { name: "s", tl: [0, 0], positions: [[2, 0], [0, 1], [1, 1], [1, 0]], color: "green", orientation: 0 }
            ];


            function startGame() {
                const startm = new Audio('start.mp3');
                musicOn ? startm.play() : null;
                document.addEventListener('keydown', keyDownHandler, false);

                gameArray = Array.from({ length: hTile }, () => Array(wTile).fill(null));
                bag = []
                currentTetro = nextTetro = null;
                score = lines = 0;
                level = 1;
                // also restart
                resetSoftLock();
                clearTimeout(softAnimation)
                popQueue();
                speed = speedTable[0];
                drawInterval = setInterval(draw, 16);
                gameInterval = setInterval(drop, speed);
            }

            let soft = 1;
            let softAnimation; // ssoftness animation call
            let isSoftLocked = false; // Flag to track soft lock status
            let lockDelay = 500;
            let beginningToLock;

            function lock() {

                let occupiedCorners = 0;
                if (currentTetro.name === "t") {

                    if (checkCollision(currentTetro, 0, 1) && checkCollision(currentTetro, 0, -1) && checkCollision(currentTetro, 1, 0) && checkCollision(currentTetro, -1, 0)) {
                        occupiedCorners = 3;
                    }

                    /*
                    corner1 = [tl[0], tl[1]];
                    if (tl[1] >= hTile || tl[0] >= wTile || tl[1] < 0 || tl[0] < 0) { occupiedCorners++ } else
                        if (gameArray[tl[1]][tl[0]] !== null) { occupiedCorners++ };
 
                    if (tl[1] >= hTile || tl[0] + 2 >= wTile || tl[1] < 0 || tl[0] + 2 < 0) { occupiedCorners++ } else
                        if (gameArray[tl[1]][tl[0] + 2] !== null) { occupiedCorners++ };
 
                    if (tl[1] + 2 >= hTile || tl[0] >= wTile || tl[1] + 2 < 0 || tl[0] < 0) { occupiedCorners++ } else
                        if (gameArray[tl[1] + 2][tl[0]] !== null) { occupiedCorners++ };
 
                    if (tl[1] + 2 >= hTile || tl[0] + 2 >= wTile || tl[1] + 2 < 0 || tl[0] + 2 < 0) { occupiedCorners++ } else
                        if (gameArray[tl[1] + 2][tl[0] + 2] !== null) { occupiedCorners++ };
                    */

                }


                isSoftLocked = false; // Reset soft lock flag
                for (let i = 0; i < currentTetro.positions.length; i++) {
                    const [x, y] = currentTetro.positions[i];
                    gameArray[y + currentTetro.tl[1]][x + currentTetro.tl[0]] = {
                        name: "standalone",
                        color: currentTetro.color
                    };
                }

                let harddropS = new Audio('harddrop.mp3');



                if (!popQueue()) {
                    return;
                }

                clearLine();
                clearInterval(gameInterval)
                gameInterval = setInterval(drop, speed)
                clearInterval(softAnimation);


                // Check if the T-spin conditions are met
                if (occupiedCorners >= 3) {
                    const tspin = new Audio('tspin.mp3');
                    harddropS = new Audio('harddrop2.mp3');
                    musicOn ? tspin.play() : null;
                    messageCh("T-Spin", 400 * level);
                    score += 400 * level;

                }

                musicOn ? harddropS.play() : null;
                soft = 1;
            }

            function drop() {

                if (checkCollision(currentTetro, 0, 1) === true) {
                    if (!isSoftLocked) {
                        isSoftLocked = true;
                        soft = 1;
                        clearInterval(gameInterval); // Stop the game interval
                        beginningToLock = setTimeout(lock, lockDelay);
                        softAnimation = setInterval(softTrans, 16); // Start softness animation
                    }
                } else {
                    currentTetro.tl[1] += 1;
                    resetSoftLock();
                }
            }

            function softTrans() {
                if (soft < 0) {
                    soft = 1;
                } else {
                    soft -= (16 / lockDelay);
                }
            }

            function moveRight(margin = 1) {
                if (checkCollision(currentTetro, margin, 0) === false) {
                    const moveS = new Audio('move.mp3');
                    musicOn ? moveS.play() : null;
                    currentTetro.tl[0] += margin;
                    resetSoftLock();
                }

            }

            function moveLeft(margin = 1) {
                if (checkCollision(currentTetro, -margin, 0) === false) {
                    const moveS = new Audio('move.mp3');
                    musicOn ? moveS.play() : null;
                    currentTetro.tl[0] -= margin;
                    resetSoftLock();
                }

            }


            function clearLine() {
                let clearedLineCount = 0;
                let linesToClear = []; // To store the indices of lines to clear

                // Check which lines need to be cleared
                for (let i = 0; i < hTile; i++) {
                    let allBlock = true;
                    for (let j = 0; j < wTile; j++) {
                        if (gameArray[i][j] === null) {
                            allBlock = false;
                            break;
                        }
                    }
                    if (allBlock) {
                        linesToClear.push(i);
                        clearedLineCount++;
                    }
                }

                if (linesToClear.length > 0) {
                    if (linesToClear.length > 3) {
                        flashCanvas();
                        const tetrisclear = new Audio('tetrisclear.mp3');
                        musicOn ? tetrisclear.play() : null;
                    } else {
                        const clearS = new Audio('clear.mp3');
                        musicOn ? clearS.play() : null;
                    }

                    // Clear lines block by block immediately
                    linesToClear.forEach(lineIndex => {
                        for (let j = 0; j < wTile; j++) {
                            // Clear the specified block
                            gameArray[lineIndex][j] = null;
                        }

                        // Shift the gameArray after the blocks are cleared
                        for (let i = lineIndex; i > 0; i--) {
                            for (let j = 0; j < wTile; j++) {
                                gameArray[i][j] = gameArray[i - 1][j];
                            }
                        }
                        // Clear the top row
                        for (let j = 0; j < wTile; j++) {
                            gameArray[0][j] = null;
                        }
                    });
                    updateGameParameters(clearedLineCount);
                } else {
                    lastLineCleared = 0;
                }
            }
            function updateGameParameters(clearedLineCount) {
                // Update score
                if (clearedLineCount === 1) {
                    score += 100 * level;
                    messageCh("Single", 100);
                } else if (clearedLineCount === 2) {
                    score += 300 * level;
                    messageCh("Double", 300);
                } else if (clearedLineCount === 3) {
                    score += 500 * level;
                    messageCh("Triple", 500);
                } else if (clearedLineCount === 4) {
                    score += 800 * level;
                    messageCh("TETRIS!", 800);
                }

                // Update level
                if (Math.floor((clearedLineCount + lines) / 10) != (level - 1)) {
                    level++;
                    speed = speedTable[level - 1];
                    messageCh("Level Up! " + level, "");
                }

                lines += clearedLineCount;

                if (lastLineCleared != 0) {
                    combo++;
                } else {
                    combo = 0;
                }

                lastLineCleared = clearedLineCount;

                // Update combo score
                if (combo > 0) {
                    if (combo == 1) {
                        const comboS = new Audio('combo1.mp3');
                        musicOn ? comboS.play() : null;
                    }
                    if (combo == 2) {
                        const comboS = new Audio('combo2.mp3');
                        musicOn ? comboS.play() : null;
                    }
                    if (combo == 3) {
                        const comboS = new Audio('combo3.mp3');
                        musicOn ? comboS.play() : null;
                    }
                    if (combo == 4) {
                        const comboS = new Audio('combo4.mp3');
                        musicOn ? comboS.play() : null;
                    }
                    score += (combo + 1) * 50 * level;
                    messageCh((combo + 1) + "x Combo!", (combo - 1) * 50 * level);
                }
                // Remove any messages after a delay

            }

            function dropButton() {
                if (isSoftLocked) {
                    resetSoftLock();
                    hardDrop();
                } else {
                    drop();
                    const moveS = new Audio('move.mp3');
                    musicOn ? moveS.play() : null;
                    score += 1;
                }
            }

            function resetSoftLock() {
                if (isSoftLocked) {
                    isSoftLocked = false;
                    clearInterval(softAnimation);
                    clearTimeout(beginningToLock);
                    soft = 1;
                    clearInterval(gameInterval);
                    gameInterval = null;
                    gameInterval = setInterval(drop, speed);
                }
            }

            function hardDrop() {

                if (isSoftLocked) {
                    resetSoftLock();
                }

                let cells = 0;

                while (checkCollision(currentTetro, 0, 1) === false) {
                    currentTetro.tl[1] += 1;
                    cells++;
                }

                dash = 2;
                let dashInterval = setInterval(function () {
                    dash -= 0.1;
                    if (dash < 0) {
                        dash = 0;
                        dashPos = [];
                        clearInterval(dashInterval);
                    }
                }, 16);

                // Put the tetromino
                lock();
                score += 2 * cells;
            }


            function calcGhost(tetro) {
                while (checkCollision(tetro, 0, 1) === false) {
                    tetro.tl[1] += 1;
                }
            }

            function holdTetro() {
                const holdS = new Audio('hold.mp3');
                musicOn ? holdS.play() : null;

                resetSoftLock();

                let temp = currentTetro;

                if (heldTetro == null) {
                    popQueue();
                    heldTetro = temp;
                } else {
                    currentTetro = heldTetro;
                    heldTetro = temp;
                }

                currentTetro.tl = overlayPosition();
            }

            function popQueue() {

                resetSoftLock();

                if (bag.length === 0) {
                    bag = JSON.parse(JSON.stringify(tetrominos));
                    shuffleArray(bag);
                }
                currentTetro = nextTetro;
                nextTetro = bag.pop();
                // set position
                // first iteration
                if (currentTetro == null) {
                    currentTetro = nextTetro;
                    nextTetro = bag.pop();
                }
                if (checkCollision(currentTetro, 4, 0) != false) {
                    clearInterval(gameInterval);
                    gameInterval = null;
                    endGame();
                    return false;
                } else {
                    currentTetro.tl = overlayPosition()
                }
                return true;

            }

            function overlayPosition() {
                if (currentTetro.name == "i") return [3, -1]
                return [3, 0]

            }

            function endGame() {
                clearInterval(gameInterval);
                gameInterval = null;
                clearInterval(drawInterval)
                document.removeEventListener('keydown', keyDownHandler, false);
                const failS = new Audio('fail.mp3');
                musicOn ? failS.play() : null;
                ctx.clearRect(0, 0, cw, ch);
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.shadowBlur = 0;
                ctx.shadowColor = "cyan"
                ctx.fillText("Game Over", cw / 2, (ch - subbar) / 2 + ch * -0.10);
                ctx.fillText("Final Score: " + score, cw / 2, (ch - subbar) / 2 + + ch * -0.07);
                let x = document.cookie;
                if (score > x) {
                    document.cookie = score;
                }
                ctx.fillText("Highest Score: " + document.cookie, cw / 2, (ch - subbar) / 2 + ch * -0.04);
                ctx.shadowBlur = 0;
                drawStartButton();
         
            }


            function checkCollision(tetro, x, y) {
                // x, y is the vector for the potential next move
                for (let i = 0; i < tetro.positions.length; i++) {
                    let newX = tetro.positions[i][0] + tetro.tl[0] + x;
                    let newY = tetro.positions[i][1] + tetro.tl[1] + y;

                    if (newY >= hTile || newX < 0 || newX >= wTile || (newY >= 0 && gameArray[newY][newX] != null)) {
                        return true; // Collision with something other than a wall
                    }
                }
                return false;
            }

            const wallKickData = {
                "0>>1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
                "1>>0": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
                "1>>2": [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
                "2>>1": [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
                "2>>3": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
                "3>>2": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
                "3>>0": [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
                "0>>3": [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
            };

            const wallKickDataI = {
                "0>>1": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],
                "1>>0": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],
                "1>>2": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],
                "2>>1": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],
                "2>>3": [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],
                "3>>2": [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],
                "3>>0": [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]],
                "0>>3": [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]]
            };


            function rotate(mode = "cw") {

                if (currentTetro.name === "o") {
                    return;
                }
                const rotateS = new Audio('rotate.mp3');
                if (musicOn) {
                    rotateS.play();
                }
                // Save the current positions before rotating
                let oldPos = JSON.parse(JSON.stringify(currentTetro.positions));
                let oldTl = JSON.parse(JSON.stringify(currentTetro.tl));
                let oldOrientation = currentTetro.orientation;

                // Rotate the tetromino points
                rotatePointsCw(mode);

                let currentRotate = oldOrientation;
                let nextRotate = currentTetro.orientation;

                let identifier = `${currentRotate}>>${nextRotate}`;
                // Wall kicks
                let kickApplied = false;

                // redundant for 0...
                for (let i = 0; i < 5; i++) {
                    let kickX;
                    let kickY;
                    if (currentTetro.name == "i") {
                        kickX = wallKickDataI[identifier][i][0];
                        kickY = wallKickDataI[identifier][i][1];
                    } else {
                        kickX = wallKickData[identifier][i][0];
                        kickY = wallKickData[identifier][i][1];
                    }
                    if (checkCollision(currentTetro, kickX, kickY) === false) {
                        currentTetro.tl[0] += kickX;
                        currentTetro.tl[1] += kickY;
                        kickApplied = true;
                        break;
                    }
                }

                if (!kickApplied) {
                    // Revert to original position and orientation if no kicks work
                    currentTetro.positions = oldPos;
                    currentTetro.tl = oldTl;
                    currentTetro.orientation = oldOrientation;
                    // try counterclockwise
                }
                resetSoftLock();


            }



            function rotatePointsCw(mode) {
                let centerX = 0;
                let centerY = 0;

                switch (currentTetro.name) {
                    case "j":
                    case "l":
                    case "s":
                    case "z":
                    case "t":
                        centerX = 1;
                        centerY = 1;
                        break;
                    case "i":
                        centerX = 1.5;
                        centerY = 1.5;
                        break;
                    default:
                        break;
                }

                for (let i = 0; i < currentTetro.positions.length; i++) {
                    let x = currentTetro.positions[i][0] - centerX;
                    let y = currentTetro.positions[i][1] - centerY;
                    let x2;
                    let y2;
                    if (mode == "cw") {
                        x2 = -y;
                        y2 = x;
                    } else {
                        x2 = y;
                        y2 = -x;
                    }
                    currentTetro.positions[i][0] = Math.round(x2 + centerX);
                    currentTetro.positions[i][1] = Math.round(y2 + centerY);
                }
                if (mode == "cw") {
                    currentTetro.orientation = (currentTetro.orientation + 1) % 4;
                } else {
                    currentTetro.orientation = (currentTetro.orientation + 3) % 4;
                }

            }


            // ----- DRAWING


            function drawSquare(x, y, color, transparency = 1, s1 = bs) {
                const imgX = x;
                const imgY = y;


                // Draw the block image
                ctx.globalAlpha = transparency;
                ctx.drawImage(blockImage, imgX, imgY, s1, s1);

                // Set composite operation to 'multiply' for a better blend
                ctx.globalCompositeOperation = 'multiply';
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.75 * transparency; // Transparency of the tint

                ctx.fillRect(imgX, imgY, s1, s1);

                // Reset composite operation and alpha
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1.0;

            }

            function drawOutline(x, y, color, s1 = bs) {
                ctx.globalAlpha = 0.3;
                ctx.lineWidth = 2; // Width of the outline
                ctx.strokeStyle = color;
                ctx.shadowBlur = 0; // Adjust the blur radius for the glow effect
                ctx.shadowColor = color; // The color of the glow
                ctx.strokeRect(x, y, s1, s1);

                // Reset shadow properties
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                ctx.globalAlpha = 1;
            }

            function drawDash(x, y) {
                // Draw the block image
                ctx.globalAlpha = dash;
                ctx.drawImage(dashImage, x, y, bs, bs);
                // Reset alpha
                ctx.globalAlpha = 1.0;
            }

            function drawBackground(x, y) {
                // Draw the block image
                ctx.globalAlpha = 1;
                ctx.drawImage(back, x + startingPositions[0], y + startingPositions[1], bs, bs);

            }

            function drawTetromino(tetromino) {
                for (let i = 0; i < tetromino.positions.length; i++) {
                    const x = tetromino.positions[i][0];
                    const y = tetromino.positions[i][1];
                    drawSquare((x + tetromino.tl[0]) * bs + startingPositions[0], (y + tetromino.tl[1]) * bs + startingPositions[1], tetromino.color, soft);
                    //drawOutline((x + tetromino.tl[0]) * bs + startingPositions[0], (y + tetromino.tl[1]) * bs + startingPositions[1], tetromino.color);

                }

                // Draw ghost tetromino
                let ghost = JSON.parse(JSON.stringify(tetromino));
                calcGhost(ghost);

                for (let i = 0; i < ghost.positions.length; i++) {
                    drawSquare((ghost.positions[i][0] + ghost.tl[0]) * bs + startingPositions[0], (ghost.positions[i][1] + ghost.tl[1]) * bs + startingPositions[1], ghost.color, 0.2);
                    //drawOutline((ghost.positions[i][0] + ghost.tl[0]) * bs + startingPositions[0], (ghost.positions[i][1] + ghost.tl[1]) * bs + startingPositions[1], ghost.color);
                }
            }

            function drawNext(tetromino, a, b) {

                if (tetromino == null) return;

                for (let i = 0; i < tetromino.positions.length; i++) {
                    const [x, y] = tetromino.positions[i];
                    drawSquare(x * (bs / 1.25) + a, y * (bs / 1.25) + b, tetromino.color, 1, bs / 1.25);
                }

            }

            let drawInterval;

            let clearLineTime = 250;
            let flashDuration = clearLineTime / 3.5; // duration of the flash in milliseconds
            let flashColor = "rgba(255, 255, 255, 0.3)"; // color and transparency of the flash

            function flashCanvas() {
                let flashCount = 0;
                let maxFlashes = 5; // Number of flashes
                let startTime = null;

                function drawFlash(timestamp) {
                    if (!startTime) startTime = timestamp;
                    let elapsed = timestamp - startTime;

                    // Draw the flashing effect
                    if (elapsed < flashDuration) {
                        // Calculate the transparency based on the elapsed time
                        let opacity = 1 - (elapsed / flashDuration);
                        canvas.style.backgroundColor = `rgba(255, 255, 255, ${opacity})`
                        requestAnimationFrame(drawFlash);
                    } else {
                        flashCount++;
                        if (flashCount < maxFlashes) {
                            // Reset the start time and continue flashing
                            startTime = null;
                            requestAnimationFrame(drawFlash);
                        } else {
                            // End of the flash, clear the canvas
                            // Redraw the game state here if necessary
                            canvas.style.backgroundColor = "black"
                        }
                    }
                }

                requestAnimationFrame(drawFlash);
            }

            const speedTable = {
                0: 860, //799,
                1: 715,
                2: 632,
                3: 549,
                4: 466,
                5: 383,
                6: 300,
                7: 216,
                8: 133,
                9: 100,
                10: 83,
                11: 83,
                12: 83,
                13: 67,
                14: 67,
                15: 67,
                16: 50,
                17: 50,
                18: 50,
                19: 33,
                20: 33,
                21: 33,
                22: 33,
                23: 33,
                24: 33,
                25: 33,
                26: 33,
                27: 33,
                28: 33,
                29: 20
            };

            let messageDelay = 500;
            let message = "";
            let points = "";
            let messageRemoveTimeout;

            function messageRemove() {
                setTimeout(() => {
                    message = "";
                    points = "";
                }, messageDelay);
            }

            function messageCh(m, p) {
                if (message != "") {
                    clearTimeout(messageRemoveTimeout);
                    // new timeout
                }
                message = m;
                points = p;
                messageRemoveTimeout = setTimeout(messageRemove, messageDelay);
            }


            function drawScore() {
                ctx.textAlign = "left";
                const fontSize = Math.min(cw, ch) / 20; // Adjust the font size dynamically
                ctx.font = `${fontSize}px Roboto`;
                ctx.fillStyle = "white";

                const xPos = cw * 0.75; // Position the score text dynamically
                const yPosStart = ch * 0.5;
                const lineHeight = fontSize * 1.5; // Line height based on the font size
                ctx.shadowBlur = 0;
                ctx.shadowColor = "cyan"
                ctx.fillText("Score: ", xPos, yPosStart);
                ctx.fillText(score, xPos, yPosStart + lineHeight);
                ctx.fillText("Level: " + level, xPos, yPosStart + 2 * lineHeight);
                ctx.fillText("Lines: " + lines, xPos, yPosStart + 3 * lineHeight);
                ctx.shadowBlur = 0;

            }

            function draw() {
                const matrixOutlineWidth = 2; // Adjust this value to set the width of the outline
                ctx.clearRect(0, 0, cw, ch);

                // Draw outline for Tetris matrix
                ctx.strokeStyle = "cyan";
                ctx.shadowBlur = 0;
                ctx.shadowColor = "cyan"

                ctx.lineWidth = matrixOutlineWidth;
                ctx.strokeRect(startingPositions[0], startingPositions[1], wTile * bs, hTile * bs);
                ctx.shadowBlur = 0;
                // Draw background for Tetris matrix
                ctx.fillStyle = "black";
                ctx.fillRect(startingPositions[0], startingPositions[1], wTile * bs, hTile * bs);

                // Draw score, buttons, and other UI elements
                drawScore();
                drawButtons();

                // Draw tetrominoes from the array
                for (let i = 0; i < hTile; i++) {
                    for (let j = 0; j < wTile; j++) {
                        if (gameArray[i][j] == null) {
                            drawBackground(j * bs, i * bs);
                        } else {
                            drawSquare(j * bs + startingPositions[0], i * bs + startingPositions[1], gameArray[i][j].color);
                            //drawOutline(j * bs + startingPositions[0], i * bs + startingPositions[1], gameArray[i][j].color);

                        }
                    }
                }

                // Draw ghost
                if (dash > 0) {
                    for (let i = 0; i < dashPos.length; i++) {
                        const [x, y] = dashPos[i];
                        drawDash(startingPositions[0] + x * bs, startingPositions[1] + y * bs); // Assuming drawDash takes coordinates in pixels
                    }
                }

                // Draw next tetromino
                ctx.fillStyle = "white";
                ctx.textAlign = "left";
                const fontSize = Math.min(cw, ch) / 20; // Adjust the font size dynamically
                ctx.font = `${fontSize}px Roboto`;
                ctx.shadowBlur = 0;
                ctx.shadowColor = "cyan"
                ctx.fillText("Next: ", cw * 0.75, ch * 0.05);
                ctx.fillText("Hold: ", cw * 0.75, ch * 0.25);
                ctx.shadowBlur = 0;
                drawNext(nextTetro, cw * 0.75, ch * 0.07);
                ctx.fillStyle = "white";
                drawNext(heldTetro, cw * 0.75, ch * 0.27);
                drawTetromino(currentTetro);

                // Draw message and points
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.shadowBlur = 0;
                ctx.shadowColor = "green";
                ctx.globalAlpha = 0.5;
                ctx.shadowBlur = 0;
                ctx.shadowColor = "cyan";
                ctx.fillText(message, startingPositions[0] + bs * wTile / 2, startingPositions[1] + (ch - subbar) / 2 - 30);
                ctx.fillText(points != "" ? "+" + points : "", startingPositions[0] + bs * wTile / 2, startingPositions[1] + (ch - subbar) / 2 + 10);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            // Define button properties
            let buttonWidth;
            let buttonHeight;
            const buttonColor = "black";
            const buttonMargin = cw * 0.01;

            // Array to hold button objects
            const buttons = [

                { label: "ðŸ”€ Hold", action: holdTetro },
                { label: "â¬‡ï¸ Soft drop", action: dropButton },
                { label: "ðŸ”„ Rotate", action: rotate },
                { label: "â¬…ï¸ Left", action: moveLeft },
                { label: "âž¡ï¸ Right", action: moveRight },
                { label: "â¬ Hard drop", action: hardDrop },
                //{ label: "ðŸ”‡ Mute", action: muteGame },
                //{ label: "â¸ï¸ Pause", action: pauseGame },
                //{ label: "ðŸ”ƒ Rotate CCW", action: () => { rotate("ccw") } }
            ];

            // Calculate button sizes dynamically based on canvas size
            function calculateButtonSizes() {
                buttonWidth = (cw - 4 * buttonMargin) / 3; // Divide canvas width into 3 parts (left, right, down)
                buttonHeight = subbar / 2 - 5 / 3 * buttonMargin; // 10% of canvas height for button height
            }

            function handleButtonPress(button) {
                if (button.isPressed) return;
                button.isPressed = true; // Set button to pressed state
                button.action(); // Execute action
                button.intervalId = setTimeout(() => {
                    button.intervalId = setInterval(() => {
                        button.action();
                    }, 100); // Repeat action every 100 milliseconds
                }, 300); // Delay for first hold action (500 milliseconds)
            }

            function handleButtonRelease(button) {
                clearInterval(button.intervalId); // Stop repeating action
                button.isPressed = false; // Reset button state
            }

            // Draw buttons
            function drawButtons() {
                // Calculate button sizes dynamically
                calculateButtonSizes();
                // Draw each button and label
                ctx.fillStyle = buttonColor;
                const fontSize = Math.min(cw, ch) / 25; // Adjust the font size dynamically
                ctx.font = `${fontSize}px Roboto`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";

                buttons.forEach((button, index) => {
                    const x = buttonMargin + index % 3 * (buttonWidth + buttonMargin);
                    const y = ch - subbar + Math.floor(index / 3) * (buttonHeight + buttonMargin);

                    // Draw button image
                    const image = button.isPressed ? buttonPressedImage : buttonImage;
                    ctx.drawImage(image, x, y, buttonWidth, buttonHeight);
                    // Draw button label
                    ctx.fillStyle = "black";
                    ctx.fillText(button.label, x + buttonWidth / 2, y + buttonHeight / 2);
                    ctx.fillStyle = buttonColor;  // Reset fill color for next button
                });

                drawPauseButton();
            }

            // Add event listeners for touch events
            canvas.addEventListener("touchstart", function (event) {
                event.preventDefault(); // Prevent default touch behavior (like scrolling or zooming)
                const rect = canvas.getBoundingClientRect();
                const touch = event.touches[0]; // Get the first touch
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                // Check if touched inside any button
                buttons.forEach(button => {
                    const x = buttonMargin + buttons.indexOf(button) % 3 * (buttonWidth + buttonMargin);
                    const y = ch - subbar + Math.floor(buttons.indexOf(button) / 3) * (buttonHeight + buttonMargin);

                    if (isInsideButton(touchX, touchY, x, y, buttonWidth, buttonHeight)) {
                        handleButtonPress(button);
                    }
                });
            });

            canvas.addEventListener("touchend", function (event) {
                event.preventDefault(); // Prevent default touch behavior
                buttons.forEach(button => {
                    if (button.isPressed) {
                        handleButtonRelease(button);
                    }
                });
            });

            canvas.addEventListener("touchmove", function (event) {
                event.preventDefault(); // Prevent default touch behavior
                // You can add code here to handle touch movements if necessary
            });


            // Add event listeners for button press and release
            canvas.addEventListener("mousedown", function (event) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // Check if clicked inside any button
                buttons.forEach(button => {
                    const x = buttonMargin + buttons.indexOf(button) % 3 * (buttonWidth + buttonMargin);
                    const y = ch - subbar + Math.floor(buttons.indexOf(button) / 3) * (buttonHeight + buttonMargin);

                    if (isInsideButton(mouseX, mouseY, x, y, buttonWidth, buttonHeight)) {
                        handleButtonPress(button);
                    }
                });
            });

            canvas.addEventListener("mouseup", function (event) {
                buttons.forEach(button => {
                    if (button.isPressed) {
                        handleButtonRelease(button);
                    }
                });
            });

            canvas.addEventListener("mouseleave", function (event) {
                buttons.forEach(button => {
                    if (button.isPressed) {
                        handleButtonRelease(button);
                    }
                });
            });

            // Event listener for start button (click)
            canvas.addEventListener("click", function (event) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // Check if clicked inside start button
                if (!gameInterval && isInsideButton(mouseX, mouseY, (cw - buttonWidth) / 2, (ch - buttonHeight) / 2, buttonWidth, buttonHeight)) {
                    // Start or restart the game
                    startGame();
                }
            });

            // Event listener for start button (touch)
            canvas.addEventListener("touchstart", function (event) {
                const rect = canvas.getBoundingClientRect();
                const touchX = event.touches[0].clientX - rect.left;
                const touchY = event.touches[0].clientY - rect.top;

                // Check if touched inside start button
                if (!gameInterval && isInsideButton(touchX, touchY, (cw - buttonWidth) / 2, (ch - buttonHeight) / 2, buttonWidth, buttonHeight)) {
                    // Start or restart the game
                    startGame();
                }
            });

            function drawStartButton() {
                calculateButtonSizes()

                ctx.fillStyle = buttonColor;
                ctx.fillStyle = "black";
                const fontSize = Math.min(cw, ch) / 20; // Adjust the font size dynamically
                ctx.font = `${fontSize}px Arial`;
                ctx.shadowBlur = 0;
                ctx.shadowColor = "cyan";
                ctx.drawImage(buttonImage, (cw - buttonWidth) / 2, (ch - buttonHeight) / 2, buttonWidth, buttonHeight);

                ctx.fontWeight = 800;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                console.log(buttonWidth)
                ctx.fillText("Start", cw / 2, ch / 2);
                ctx.fillStyle = "white";
                ctx.shadowBlur = 0;
                ctx.drawImage(logo, (cw - buttonHeight * 1.7) / 2, ch / 5, 3.66 * buttonHeight / 2, buttonHeight / 2);

                //ctx.fillText("TETRIS", cw / 2, ch / 5);

            }

            drawStartButton();

            // Event listener for pause button (click)
            canvas.addEventListener("click", function (event) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;

                // Check if clicked inside pause button
                const pauseButtonX = cw - buttonWidth * 0.75;
                const pauseButtonY = ch / 1.5 + buttonMargin;
                if (isInsideButton(mouseX, mouseY, pauseButtonX, pauseButtonY, buttonWidth / 2, buttonHeight)) {
                    // Pause the game
                    pauseGame();
                }
            });

            // Event listener for pause button (touch)
            canvas.addEventListener("touchstart", function (event) {
                const rect = canvas.getBoundingClientRect();
                const touchX = event.touches[0].clientX - rect.left;
                const touchY = event.touches[0].clientY - rect.top;

                // Check if touched inside pause button
                const pauseButtonX = cw - buttonWidth * 0.75;
                const pauseButtonY = ch / 1.5 + buttonMargin;
                if (isInsideButton(touchX, touchY, pauseButtonX, pauseButtonY, buttonWidth / 2, buttonHeight)) {
                    // Pause the game
                    pauseGame();
                }
            });

            function drawPauseButton() {
                calculateButtonSizes();

                const pauseButtonX = cw - buttonWidth * 0.75;
                const pauseButtonY = ch / 1.5 + buttonMargin;
                ctx.fillStyle = "black";
                const fontSize = Math.min(cw, ch) / 20; // Adjust the font size dynamically
                ctx.font = `${fontSize}px Arial`;
                ctx.shadowBlur = 0;
                ctx.shadowColor = "cyan";
                ctx.drawImage(buttonImage, pauseButtonX, pauseButtonY, buttonWidth / 2, buttonHeight);

                ctx.fontWeight = 800;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("â¸ï¸", pauseButtonX + buttonWidth / 4, pauseButtonY + buttonHeight / 2);
            }

            // Function to check if a point is inside a button
            function isInsideButton(x, y, buttonX, buttonY, buttonWidth, buttonHeight) {
                return x > buttonX && x < buttonX + buttonWidth && y > buttonY && y < buttonY + buttonHeight;
            }

            document.addEventListener('keydown', keyDownHandler, false);

            function keyDownHandler(e) {
                e.preventDefault();
                if (e.key === "Right" || e.key === "ArrowRight") {
                    moveRight()
                }
                if (e.key === "Left" || e.key === "ArrowLeft") {
                    moveLeft()
                }
                if (e.key === "Down" || e.key === "ArrowDown") {
                    dropButton();
                }
                if (e.key === "Up" || e.key === "ArrowUp") {
                    rotate();
                }
                if (e.key === " " || e.key === "Spacebar") {
                    if (gameInterval == null) {
                        startGame();
                    }
                    hardDrop() // hard drop
                }
                if (e.key === "c") {
                    holdTetro();
                }
                if (e.key === "x") {
                    rotate();
                }
                if (e.key === "z") {
                    rotate("ccw");
                }
                if (e.key === "a") {
                    clearInterval(gameInterval)
                    clearInterval(drawInterval);
                    startGame();
                }
                if (e.key === "Escape") {
                    pauseGame();
                }
                if (e.key === "m") {
                    muteGame();
                }
            }


            // ----------------------- shuffle array
            function shuffleArray(array) {
                for (var i = array.length - 1; i > 0; i--) {
                    var j = Math.floor(Math.random() * (i + 1));
                    var temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }

            let paused = false;
            function pauseGame() {
                if (paused) {
                    paused = false;
                    const startm = new Audio('start.mp3');
                    musicOn ? startm.play() : null;
                    gameInterval = setInterval(drop, speed)
                    drawInterval = setInterval(draw, 16)
                } else {
                    ctx.shadowBlur = 0;
                    ctx.shadowColor = "cyan"
                    paused = true;
                    const pause = new Audio('pause.mp3');
                    musicOn ? pause.play() : null;
                    ctx.clearRect(0, 0, cw, ch);
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    ctx.fillText("Paused...", cw / 2, (ch - subbar) / 2 - 30);
                    clearInterval(gameInterval);
                    clearInterval(drawInterval)
                    ctx.shadowBlur = 0
                    drawPauseButton();
                }
            }

            function muteGame() {
                musicOn = !musicOn;
            }
        });

        const blockImage = new Image();
        blockImage.src = "block.png"
        const back = new Image();
        back.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAREAAAESCAMAAADt3hESAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAB4UExURSYmJiQkJBoaGhMTEw8PDwsLCwcHBwQEBAAAAA4ODhkZGR8fHxYWFg0NDQMDAwwMDBUVFR4eHgoKCggICB0dHQICAgEBARwcHBERERgYGAUFBRQUFCUlJQYGBhsbGyEhIRISEhAQECAgIBcXFyMjIyIiIgkJCQAAAPTXCu8AAAAodFJOU////////////////////////////////////////////////////wC+qi4YAAAACXBIWXMAADLAAAAywAEoZFrbAAAD0klEQVR4Xu3Y0W0cOxBEUX5uCEyA+adokE1yhndGDmD6HujnScYDVKhmrV2aToXfSK+0orveEX4vNzsC/7ma1mqtv0+qtdb+YLxq44t6GvzffE6tL7/5H+9I+34c4aUpLxVpafLoHj0Zn0fO72TKo6sM4OxIroKEsybcmsY/nsLxmpwPSb6ChHpFcG5NzoZ0VyS3irSWN5Dfb9fivjWZA+lvyYphdSTjyhx2DjuR5IHsEV4PSepHJOxE5gFlr8j68GpFbmYS0ZH0r8gQkYyOWJEhooirsSLdmJt4SDyaYXyWj3fEowlxMv3LRELdW+PRhP6QxMtqIqE/JCZymFOT/q+923xHnJrLfkf4g7TG0PSt4Q/SsiNkIrQ/tPIHac3tNZHNqyG3huwImQi5NeTWkFdDbg3ZETIRcmvIrSGvhtwasiNkIuTWkFtDXg25NWRHyETIrSG3hrwacmvIjpCJkFtDbg15NeTWkB0hEyG3htwa8mrIrSE7QiZCbg25NeTVkFtDdoRMhNwacmvIqyG3huwImQi5NeTWkFdDbg3ZETIRcmvIrSGvhtwasiNkIuTWkFtDXg25NWRHyETIrSG3hrwacmvIjpCJkFtDbg15NeTWkB0hEyG3htwa8mrIrSE7QiZCbg25NeTVkFtDdoRMhNwacmvIqyG3huwImQi5NeTWkFdDbg3ZETIRcmvIrSGvhtwasiNkIuTWkFtDXg25NWRHyETIrSG3hrwacmvIjpCJkFtDbg15NeTWkB0hEyG3htwa8mrIrSE7QiZCbg25NeTVkFtDdoRMhNwacmvIqyG3huwImQi5NeTWkFdDbg3ZETIRcmvIrSGvhtwasiNkIuTWkFtDXg25NWRHyETIrSG3hrwacmvIjpCJkFtDbg15NeTWkB0hEyG3htwa8mrIrSE7QiZCbg25NeTVkFtDdoRMhNwacmvIqyG3huwImQi5NeTWkFdDbg3ZETIRcmvIraF1NY0/SKuMrSmlVP4kKztCZb0jdiTUNTXNREL1HYE6G1KaD0noVzO/+KOk+psaV+NDMvSjMZG7mcj48my6cTTxecSSDBHFuBoT6UYg8zOrH0m6WZHZEV+S/re8kUQkUlr6u6nzWFZJnJs2n5H9jmSPZAaytyb9U7Ju5rY1uZ+S8Wl1BrI7kvlTyRXItTXrP/lnU7gF8ihJykjuedy3ZiaS7nLqXpmZwXE1+WpSeyBM5BlJnkyu0d2//vGMrG8muZ1nHM+tub7dSqv199lcalzL6+/+VpKh39On8RcO2JqH61/rP/QVv9hf3q8ms5GaLq38AzNfpmOwOgUUAAAAAElFTkSuQmCC"
        const dashImage = new Image();
        dashImage.src = "data:image/png;base64,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";

    </script>
</body>

</html>